package puzzlesolver.model;

import java.util.HashSet;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * Represents the pieces that have not yet been placed in the box
 *
 * @author Maikel Steneker (0753708)
 * @since 3-4-2011
 *
 * Invariants:
 * @inv {\forall i,j; 0 <= i < j <= pieces.length; !pieces[i].equals(pieces[j])}
 * @inv pieces.length == multiplicity.length
 * @inv {\forall i; 0 <= i < multiplicity.length; m[i] >= 0}
 */
public class BagOfPieces implements Iterable<Piece> {
    //Internal representation:
    private Piece[] pieces;
    private int[] multiplicity;

    /**
     * Constructs the BagOfPieces class
     *
     * @pre      {@code true}
     * @param    pieces  array containing the pieces in the bag
     * @modifies pieces
     * @modifies multiplicity
     * @post     {@code this.pieces = pieces}
     * @throws   IllegalArgumentException  If {\exists i,j; 0 <= i < j <=
     *                          pieces.length; pieces[i].equals(pieces[j])}
     */
    public BagOfPieces(Piece[] pieces) throws IllegalArgumentException {
        //check precondition
        for (int i = 0; i < pieces.length; i++) {
            for (int j = i; j < pieces.length; j++) {
                if (i != j && pieces[i].equals(pieces[j])) {
                    throw new IllegalArgumentException("While constructing "
                            + "BagOfPieces: pieces[" + i + "] == pieces[" + j +
                            "].");
                }
            }
        }
        this.pieces = pieces;
        this.multiplicity = countMultiplicity(pieces);
        removeDuplicates();
    }

    /**
     * Counts the multiplicity of each Piece in a
     *
     * @pre   {@code a != null}
     * @param a  array of pieces to count multiplicity
     * @return {\forall i; 0 <= i < a.length;
     *              {\forall j; 0 <= j < i; !a[i].equals(a[j])} ? m : 0}
     *              with m as the number of duplicates of a[i] + 1
     */
    private int[] countMultiplicity(Piece[] a) {
        Set<Piece> hasBeenCounted = new HashSet(); //set of pieces that
                                                   //have been counted
        int[] m = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            if (!hasBeenCounted.contains(a[i])) {
                //the element has not yet been counted
                m[i] = 1;

                //check for duplicate elements
                for (int j = i; j < a.length; j++) {
                    if (i != j && a[i].equals(a[j])) {
                        //a duplicate has been found
                        m[i]++; //increase the counter
                    }
                }
                assert hasBeenCounted.add(a[i]); //add a[i] to the counted pieces
            } else {
                //the element has already been counted
                m[i] = 0;
            }
        }
        return m;
    }

    /**
     * Removes the duplicates in {@code this.pieces} and the zero's in
     * {@code this.multiplicity}
     *
     * @pre      this.multiplicity has been generated by countMultiplicity(a)
     * @modifies pieces
     * @modifies multiplicity
     * @post     {\forall i; 0 <= i < pieces.length;
     *                              {\forall j; 0 <= j < i; !a[i].equals(a[j])}}
     * @post     {\forall i; 0 <= i < multiplicity.length; multiplicity[i] != 0}
     */
    private void removeDuplicates() {
        int count; //number of zero's in multiplicity
                   //or number of duplicate pieces in pieces
        int[] m; //replacement for multiplicity array
        Piece[] p; //replacement for pieces array
        int empty = 0; //first empty place in m or p
        Set<Piece> hasBeenCounted = new HashSet(); //set of pieces that
                                                   //have been counted

        //count the number of zero's in multiplicity
        count = 0;
        for (int e : multiplicity) {
            if (e == 0) {
                count++;
            }
        }

        //copy all non-zero elements to m
        m = new int[multiplicity.length - count];
        empty = 0;
        for (int i = 0; i < multiplicity.length; i++) {
            if (multiplicity[i] != 0) {
                //store multiplicity[i] in m on the first empty place
                m[empty] = multiplicity[i];
                empty++; //increase value of empty
            }
        }
        assert (empty == multiplicity.length - count);

        //replace multiplicity by m
        this.multiplicity = m;

        //count duplicate entries in this.pieces and replace them by null
        count = 0;
        for (int i = 0; i < pieces.length; i++) {
            if (!hasBeenCounted.contains(pieces[i])) {
                //pieces[i] has not yet been counted
                //add pieces[i] to the counted pieces
                assert hasBeenCounted.add(pieces[i]);
            } else {
                //pieces[i] has been counted
                assert hasBeenCounted.contains(pieces[i]);
                //replace it by null
                pieces[i] = null;
                //increase the counter
                count++;
            }
        }

        //copy all non-null elements to p
        p = new Piece[pieces.length - count];
        empty = 0;
        for (int i = 0; i < pieces.length; i++) {
            if (pieces[i] != null) {
                //store pieces[i] in p on the first empty place
                p[empty] = pieces[i];
                empty++; //increase the value of empty
            }
        }
        assert (empty == multiplicity.length - count);

        //replace pieces by p
        this.pieces = p;
    }

    /**
     * Constructs the BagOfPieces class
     *
     * @pre      {@code true}
     * @param    pieces  array containing the pieces in the bag
     * @param    multiplicity  array containing the multiplicity of the pieces
     * @modifies pieces
     * @modifies multiplicity
     * @post     {@code this.pieces = pieces}
     * @post     {@code this.multiplicity = multiplicity}
     * @throws   IllegalArgumentException  If {\exists i,j; 0 <= i < j <
     *                          pieces.length; pieces[i].equals(pieces[j])} ||
     *                          (pieces.length != multiplicity.length)
     */
    public BagOfPieces(Piece[] pieces, int[] multiplicity)
            throws IllegalArgumentException {
        //check precondition
        if (pieces.length != multiplicity.length) {
            throw new IllegalArgumentException("While constructing BagOfPieces:"
                    + " pieces.length != multiplicity.length.");
        }
        for (int i = 0; i < pieces.length; i++) {
            for (int j = i; j < pieces.length; j++) {
                if (i != j && pieces[i].equals(pieces[j])) {
                    throw new IllegalArgumentException("While constructing "
                            + "BagOfPieces: pieces[" + i + "] == pieces[" + j +
                            "].");
                }
            }
        }
        this.pieces = pieces;
        this.multiplicity = multiplicity;
    }

    /**
     * Get the value of pieces at specified index
     *
     * @param index
     * @return the value of pieces at specified index
     */
    public Piece getPiece(int index) {
        return this.pieces[index];
    }

    /**
     * Get the value of multiplicity at specified index
     *
     * @param index
     * @return the value of multiplicity at specified index
     */
    public int getMultiplicity(int index) {
        return this.multiplicity[index];
    }

    /**
     * Reduces the multiplicity of a piece by 1
     * 
     * @param    index  the index of the piece to be removed
     * @modifies multiplicity
     * @post     {@code multiplicity[index]=={\old multiplicity[index]} - 1}
     * @throws   IndexOutOfBoundsException  If index < 0 
     *                                          || index >= multiplicity.length
     * @throws   IllegalStateException  If multiplicity[index] == 0
     */
    public void removePiece(int index) throws IndexOutOfBoundsException {
        //check precondition
        if (index < 0) {
            throw new IndexOutOfBoundsException("While executing removePiece("
                    + index + "): index < 0");
        }
        if (index >= multiplicity.length) {
            throw new IndexOutOfBoundsException("While executing removePiece("
                    + index + "): index >= " + multiplicity.length);
        }
        if (multiplicity[index] == 0) {
            throw new IllegalStateException("While executing removePiece("
                    + index + "): there are no pieces left.");
        }
        //remove piece
        multiplicity[index]--;
    }

    /**
     * Restores a piece that has previously been removed
     *
     * @param    index  the index of the piece to be restored
     * @modifies multiplicity
     * @post     {@code multiplicity[index]=={\old multiplicity[index]} + 1}
     * @throws   IndexOutOfBoundsException  If index < 0
     *                                          || index >= multiplicity.length
     */
    public void restorePiece(int index) {
        //check precondition
        if (index < 0) {
            throw new IndexOutOfBoundsException("While executing restorePiece("
                    + index + "): index < 0");
        }
        if (index >= multiplicity.length) {
            throw new IndexOutOfBoundsException("While executing restorePiece("
                    + index + "): index >= " + multiplicity.length);
        }
        //restore piece
        multiplicity[index]++;
    }

    /**
     * Get the index of a piece in the bag
     *
     * @param  piece  the piece to look for
     * @return the index of the piece
     * @throws IllegalArgumentException  If {\forall i; 0 <= i < pieces.length;
     *                                      !getPiece(i).equals(piece)}
     */
    public int getIndex(Piece piece) {
        for (int i = 0; i < pieces.length; i++) {
            if (getPiece(i).equals(piece)) {
                //the piece has been found
                return i;
            }
        }
        //the piece could not be found
        throw new IllegalArgumentException("While executing getIndex("
                + piece.toString() + "): piece is not in this bag.");
    }

    /**
     * Returns foreach iterator over {@code pieces}
     *
     * @return iterator
     */
    public Iterator<Piece> iterator() {
        return new BagOfPiecesIterator();
    }

    /**
     * Returns whether or not the bag is empty
     *
     * @return {\forall i; 0 <= i < pieces.length; multiplicity[i] == 0}
     */
    public boolean isEmpty() {
        for (int m : multiplicity) {
            if (m > 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Inner iteration class
     */
    public class BagOfPiecesIterator implements Iterator<Piece> {
        private int i; //index of next element
        private int sentinel; //index of the last element + 1

        BagOfPiecesIterator() {
            i = 0;
            sentinel = pieces.length;
        }

        /**
         * Determines whether or not there is a next piece
         *
         * @return {@code (i < sentinel)}
         */
        public boolean hasNext() {
            return (i < sentinel);
        }

        /**
         * Returns the next element
         *
         * @return getPiece(i++)
         * @throws NoSuchElementException  If (i == sentinel)
         */
        public Piece next() throws NoSuchElementException {
            if (i==sentinel) {
                throw new NoSuchElementException("BagOfPiecesIterator.next");
            }
            return getPiece(i++);
        }

        /**
         * Removes the last element returned by the iterator
         */
        public void remove() {
            throw new UnsupportedOperationException("Not supported.");
        }

    }
}
